#!/usr/bin/env python3
# Copyright (C) 2025 ff794e44ea1c2b5211a3b07c57b5a3813f87f53ac10d78e56b16b79db6ff9615
#                    b726ae7cf45cc4dfa8de359caffb893209bca614d9387a7666b106052fba3e50
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
#
# DMCA Security Research Exemption:
# Good faith security research conducted consistent with 17 U.S.C. ยง1201(j) and
# 37 CFR ยง201.40(b)(7) is explicitly permitted.
#
# This software is intended solely for educational, forensic, and lawful
# security research purposes. Any use of this software for offensive or harmful
# purposes is expressly prohibited.
#
# DISCLAIMER:
# The author disclaims any responsibility or liability for any direct, indirect,
# incidental, or consequential damages or losses resulting from the use or
# misuse of this software. Users bear full responsibility for compliance with
# applicable laws and regulations.
#
# Use, modification, or distribution constitutes explicit agreement to all terms
# above.

from pwn import log

def parse_cpld_registers(data: bytes) -> dict:
    """
    Parse a bytes buffer containing CPLD register data and return a dictionary
    mapping register names to their corresponding values. All values obtained
    from reverse engineering of the FastIron monolithic binary and uboot.

    :param data: A bytes buffer containing the register values.
    :return: A dictionary mapping the register names to their respective values.
    :raises ValueError: If the data buffer is not long enough.
    """
    required_length = 0x75 + 1
    if len(data) < required_length:
        raise ValueError(f"Data buffer must be at least {required_length} bytes long")

    registers = {
        'board_type':     data[0x00],
        'code_rev':       data[0x01],
        'ps1_reg':        data[0x02], # Power supply
        'reg_4_mod':      data[0x04], # QSFP/extra rear modules PS
        'fan_dir':        data[0x09], # Fan direction
        'prod_id':        data[0x10], # Product ID
        'reset_cause':    data[0x0a],
        'boot_loc':       data[0x0b], # Uboot memory bank location
        'pri_fail_rec':   data[0x0c],
        'sec_fail_rec':   data[0x0d],
        'spi_cs':         data[0x0e],
        'reset_ctrl_1':   data[0x30],
        'reset_ctrl_2':   data[0x31],
        'ipsec_module':   data[0x33], # IPSEC module control
        'sysled':         data[0x38], # System led
        'wp':             data[0x34], # Write-protect for CPLD
        'led_ctrl':       data[0x3a], # LED ctrl
        'mac_gpio_ctrl':  data[0x3b],
        'poe_hw_disable': data[0x3c], # PoE controller disable pin
        'ctl_reg1':       data[0x3e],
        'ctl_reg2':       data[0x3d],
        'wdt_ctrl':       data[0x40],
        'pwr_plug':       data[0x4b], # Power pluggable
        'reg_48':         data[0x48], # Fiber modules
        'reg_49':         data[0x49], # Fiber modules
        'code_subrev':    data[0x75],
    }
    return registers

# Platform constants
SPATHA_PLATFORM   = 0
SICA_PLATFORM     = 1
MINIONS_PLATFORM  = 2
GRU_PLATFORM      = 3

# SPATHA SKU constants
SPATHA_24G_SKU    = 0
SPATHA_48F_SKU    = 1
SPATHA_48C_SKU    = 2
SPATHA_32C_SKU    = 3

# SICA SKU constants
SICA_24L_SKU      = 0
SICA_24G_SKU      = 1
SICA_48C_SKU      = 2

# MINIONS SKU constants
MINIONS_C12_SKU   = 0
MINIONS_24_SKU    = 1
MINIONS_24P_SKU   = 2
MINIONS_48_SKU    = 3
MINIONS_48P_SKU   = 4
MINIONS_48PF_SKU  = 5
MINIONS_48ZP_SKU  = 6

# GRU SKU constants
GRU_C08P_SKU      = 0
GRU_C10ZP_SKU     = 1
GRU_24F_SKU       = 2
FROZONE_C08PT_SKU = 3

# Hardware revision constants
PROTO = 0
ALPHA = 1
BETA  = 2
PVT   = 3

# --- Helper functions ---

def get_platform_index(registers: dict) -> int:
    """
    Determine the platform index using bits 5:4 from the 'prod_id' register.
    """
    data = registers.get('prod_id', 0)
    platform_bits = (data >> 4) & 0x3
    if platform_bits == 0x1:
        return SICA_PLATFORM
    elif platform_bits == 0x0:
        return SPATHA_PLATFORM
    elif platform_bits == 0x2:
        return MINIONS_PLATFORM
    elif platform_bits == 0x3:
        return GRU_PLATFORM
    else:
        return -1

def get_sku_details(registers: dict, platform_index: int) -> dict:
    """
    Extract SKU details from the registers dictionary based on the platform index.
    Returns a dict with keys: sku_type, hw_rev, board_rev, poe.
    The extraction is based on bit masking similar to the C code.
    """
    data = registers.get('board_type', 0)
    details = {}

    if platform_index in (SPATHA_PLATFORM, SICA_PLATFORM):
        # For SPATHA/SICA:
        #   Bits [6:5]  -> sku_type
        #   Bits [4:2]  -> hw_rev
        #   Bits [1:0]  -> board_rev (plus one)
        #   Bit 7       -> poe
        details['sku_type']  = (data & 0x60) >> 5
        details['hw_rev']    = (data & 0x1c) >> 2
        details['board_rev'] = (data & 0x03) + 1
        details['poe']       = (data >> 7) & 0x1
    elif platform_index == MINIONS_PLATFORM:
        # For MINIONS:
        #   Bits [6:4]  -> sku_type
        #   Bits [3:2]  -> hw_rev
        #   Bits [1:0]  -> board_rev (plus one)
        #   Bit 7       -> poe
        details['sku_type']  = (data & 0x70) >> 4
        details['hw_rev']    = (data & 0x0c) >> 2
        details['board_rev'] = (data & 0x03) + 1
        details['poe']       = (data >> 7) & 0x1
    elif platform_index == GRU_PLATFORM:
        # For GRU:
        #   Bits [6:4]  -> sku_type
        #   Bits [3:2]  -> hw_rev
        #   Bits [1:0]  -> board_rev (plus one)
        # For POE, read from the 'prod_id' register (bit 2).
        details['sku_type']  = (data & 0x70) >> 4
        details['hw_rev']    = (data & 0x0c) >> 2
        details['board_rev'] = (data & 0x03) + 1
        prod_id = registers.get('prod_id', 0)
        details['poe']       = (prod_id >> 2) & 0x01
    else:
        raise ValueError(f"Incorrect platform_index: {platform_index}")

    return details

def is_board_fiber(registers: dict) -> bool:
    """
    Dummy function to indicate if the board is a fiber board.
    In a real implementation, this might examine a specific register or flag.
    Here we simply return False unless a 'is_fiber' flag is present.
    """
    return registers.get('is_fiber', False)

def get_board_model(registers: dict):
    platform_index = get_platform_index(registers)

    try:
        details = get_sku_details(registers, platform_index)
    except ValueError as e:
        log.error("Error: %s", e)
        return

    sku_type  = details['sku_type']
    hw_rev    = details['hw_rev']
    board_rev = details['board_rev']
    poe       = details['poe']

    # Build the model string based on platform and SKU.
    model_str = ""

    if platform_index == SPATHA_PLATFORM:
        model_str += "ICX7450-"
        if sku_type == SPATHA_24G_SKU:
            model_str += "24 Copper"
        elif sku_type == SPATHA_48F_SKU:
            model_str += "48 Fiber"
        elif sku_type == SPATHA_48C_SKU:
            model_str += "48 Copper"
        elif sku_type == SPATHA_32C_SKU:
            model_str += "32Z Copper"
        else:
            model_str += "UNKNOWN"

    elif platform_index == SICA_PLATFORM:
        model_str += "ICX7250-"
        if sku_type == SICA_24L_SKU:
            model_str += "24G"
        elif sku_type == SICA_24G_SKU:
            model_str += "24 Copper"
        elif sku_type == SICA_48C_SKU:
            model_str += "48 Copper"
        else:
            model_str += "UNKNOWN"

    elif platform_index == MINIONS_PLATFORM:
        model_str += "ICX7150-"
        if sku_type == MINIONS_C12_SKU:
            model_str += "12"
        elif sku_type == MINIONS_24_SKU:
            model_str += "24 Copper"
        elif sku_type == MINIONS_24P_SKU:
            model_str += "24"
        elif sku_type == MINIONS_48_SKU:
            model_str += "48 Copper"
        elif sku_type == MINIONS_48P_SKU:
            model_str += "48"
        elif sku_type == MINIONS_48PF_SKU:
            model_str += "48 FULL"
        elif sku_type == MINIONS_48ZP_SKU:
            model_str += "48ZP FULL"
        else:
            model_str += "UNKNOWN"

    elif platform_index == GRU_PLATFORM:
        model_str += "ICX7150-"
        if sku_type == GRU_C08P_SKU:
            model_str += "8"
        elif sku_type == GRU_C10ZP_SKU:
            model_str += "10ZP"
        elif sku_type == GRU_24F_SKU:
            model_str += "24 Fiber"
        elif sku_type == FROZONE_C08PT_SKU:
            model_str += "8T"
        else:
            model_str += "UNKNOWN"
    else:
        log.error("Incorrect platform index: %s", platform_index)
        return

    # Append POE information.
    model_str += " (POE), " if poe else " (Non-POE), "

    # Append hardware revision letter using a mapping.
    hw_rev_mapping = {PROTO: "P", ALPHA: "A", BETA: "B", PVT: "PVT"}
    hw_str = hw_rev_mapping.get(hw_rev, str(hw_rev))
    model_str += f"{hw_str}{board_rev}"

    return model_str

def dump_cpld_info(registers: dict):
    """
    Dump selected CPLD information from the given registers dictionary,
    printing each field with a fixed-width label.
    """
    # Compute the human-readable reset cause from the reset_cause register.
    rc = registers.get('reset_cause', 0)
    reset_cause_mapping = {
         0x0: "Power Cycled",
         0x1: "PON_RESET",
         0x2: "WARM_RESET (CPU_RESET_REQ)",
         0x3: "COLD_RESET (PUSH BUTTON RESET)",
         0x8: "CPLD_RESET (WARM)",
         0x9: "CPLD_RESET (COLD)",
         0x10: "CP_RESET (excluding DDR3)",
         0x11: "WDT_WARM_RESET",
         0x12: "WDT_COLD_RESET"
    }
    reset_cause_str = reset_cause_mapping.get(rc, "Unknown")

    # Create a list of (label, value) tuples.
    lines = [
        ("Detected Model", get_board_model(registers)),
        ("System CPLD Version", f"0x{registers.get('code_rev', 0) & 0x3f:02x}:0x{registers.get('code_subrev', 0) & 0x3f:02x}"),
        ("CPLD Chip Select", f"{registers.get('spi_cs', 0)}"),
        ("Watchdog Enabled", f"0x{registers.get('wdt_ctrl', 0):02x}"),
        ("Booted from", f"{registers.get('boot_loc', 0) & 0x1}"),
        ("Primary Uboot Failure Record", f"{registers.get('pri_fail_rec', 0) & 0x3}"),
        ("Secondary Uboot Failure Record", f"{registers.get('sec_fail_rec', 0) & 0x3}"),
        ("Reset Cause", reset_cause_str),
        ("Write Protect NOR Enabled", f"{1 if (registers.get('wp', 0) & 0x4) else 0}"),
        ("Write Protect RCW Enabled", f"{1 if (registers.get('wp', 0) & 0x2) else 0}"),
        ("Write Protect PCA9561 Enabled", f"{1 if (registers.get('wp', 0) & 0x10) else 0}"),
        ("Fan direction", f"{registers.get('fan_dir', 0)}"),
        ("Pluggable module", f"{registers.get('reg_48', 0)}-{registers.get('reg_49', 0)}"),
        ("IPSEC module", f"{registers.get('ipsec_module', 0)}"),
        ("System LED", f"{registers.get('sysled', 0)}"),
        ("Power Supply", f"{registers.get('ps1_reg', 0)}"),
    ]

    # Determine maximum label length for alignment.
    max_label_length = max(len(label) for label, _ in lines)

    # Build a multiline message for the CPLD dump.
    msg = "\n".join(f"{label.ljust(max_label_length)} : {value}" for label, value in lines)
    log.info(msg)

def extract_eeprom_info(eeprom_buffer: bytes, redacted: bool = False) -> tuple:
    '''
    Extracts information from an EEPROM bytes buffer and returns a tuple (info_dict, modified_buffer).

    Assumptions:
      - The first two bytes are magic bytes and must equal 0xca 0x95.
      - The MAC address is stored in 6 bytes starting at offset 0x2.
      - The module ID is stored at offset 0x18 (1 byte).
      - The version number is stored at offset 0x19 (2 bytes); its first byte indicates the buckhound
        flag (should equal 0x12).
      - The serial number is stored at offset 0x1B and is 11 bytes long (null-terminated).
      - The part number is stored at offset 0x27 and is 13 bytes long.
      - The test date is stored at offset 0x35 and is 6 bytes long.
      - The manufacture date is stored at offset 0x3C and is 6 bytes long.
      - The factory date is stored at offset 0x43 and is 6 bytes long.
      - The burn-in date is stored at offset 0x4A and is 6 bytes long.
      - The bench test field is stored at offset 0x51 and is 2 bytes long.
      - The Mfg Test field is stored at offset 0x55 and is 10 bytes long.
      - The RMA Info field is stored at offset 0x67 and is 32 bytes long.
      - The FIPS bit is stored at offset 0xA5; it is considered set if the value equals 0xA8.

    When redacted is True, the sensitive fields are replaced in the EEPROM buffer with 'X'
    filler bytes, and their values in the info dictionary are set to 'REDACTED'.

    Parameters:
        eeprom_buffer (bytes): The EEPROM data.
        redacted (bool): If True, sensitive fields will be redacted.

    Returns:
        tuple: (info_dict, modified_eeprom_buffer)

    Raises:
        ValueError: If the buffer is too short or the magic bytes do not match.
    '''
    # Ensure the buffer is mutable.
    if not isinstance(eeprom_buffer, bytearray):
        eeprom_buffer = bytearray(eeprom_buffer)

    # Offsets and lengths.
    offsets = {
        'magic': 0,
        'mac': 2,
        'module_id': 0x18,
        'version': 0x19,      # 2 bytes: first byte gives buckhound flag
        'serial': 0x1B,
        'part_number': 0x27,
        'test_date': 0x35,
        'manuf_date': 0x3C,
        'factory_date': 0x43,
        'burnin_date': 0x4A,
        'bench_test': 0x51,
        'mfg_test': 0x55,
        'rma_info': 0x67,
        'fips': 0xA5,
        'pid_prom': 0xec,
        'module_data': 0x10,
    }
    lengths = {
        'magic': 2,
        'mac': 6,
        'module_id': 1,
        'version': 2,
        'serial': 11,
        'part_number': 13,
        'date': 6,       # used for test_date, manuf_date, factory_date, burnin_date
        'bench_test': 2,
        'mfg_test': 10,
        'rma_info': 0x20,  # 32 bytes
        'fips': 1,
        'pid_prom': 4,
        'module_data': 0x20,
    }

    # Determine the minimum required length.
    min_length = max(
        offsets['mac'] + lengths['mac'],
        offsets['fips'] + lengths['fips'],
        offsets['serial'] + lengths['serial'],
        offsets['manuf_date'] + lengths['date'],
        offsets['factory_date'] + lengths['date'],
        offsets['version'] + lengths['version'],
        offsets['part_number'] + lengths['part_number'],
        offsets['test_date'] + lengths['date'],
        offsets['bench_test'] + lengths['bench_test'],
        offsets['mfg_test'] + lengths['mfg_test'],
        offsets['rma_info'] + lengths['rma_info'],
        offsets['pid_prom'] + lengths['pid_prom'],
        offsets['module_data'] + lengths['module_data']
    )
    if len(eeprom_buffer) < min_length:
        log.error('EEPROM buffer is too short to extract required information.')
        raise ValueError('EEPROM buffer is too short to extract required information.')

    # Check magic bytes.
    magic = eeprom_buffer[offsets['magic']:offsets['magic'] + lengths['magic']]
    expected_magic = bytes([0xca, 0x95])
    if magic != expected_magic:
        log.error('Invalid magic bytes: expected %s, got %s',
                  expected_magic.hex(), magic.hex())
        raise ValueError('Invalid magic bytes in EEPROM buffer.')

    # Extract MAC address.
    mac_bytes = eeprom_buffer[offsets['mac']:offsets['mac'] + lengths['mac']]
    mac_address = ':'.join(f"{byte:02x}" for byte in mac_bytes)

    # Extract module ID.
    module_id = eeprom_buffer[offsets['module_id']]
    module_id_str = f"{module_id:02x}"

    # Extract version number and buckhound flag.
    version_bytes = eeprom_buffer[offsets['version']:offsets['version'] + lengths['version']]
    version_number = version_bytes.decode('ascii', errors='ignore').strip('\x00')
    buckhound = (version_bytes[0] == 0x12)

    # Extract serial number.
    serial_bytes = eeprom_buffer[offsets['serial']:offsets['serial'] + lengths['serial']]
    if b'\x00' in serial_bytes:
        serial_number = serial_bytes.split(b'\x00')[0].decode('ascii', errors='ignore')
    else:
        serial_number = serial_bytes.decode('ascii', errors='ignore')

    # Extract part number.
    part_number_bytes = eeprom_buffer[offsets['part_number']:offsets['part_number'] + lengths['part_number']]
    part_number = part_number_bytes.decode('ascii', errors='ignore').strip('\x00')

    # Helper function to decode and format date fields.
    def decode_format_date(offset: int) -> str:
        date_str = eeprom_buffer[offset:offset + lengths['date']].decode('ascii', errors='ignore')
        return f"{date_str[0:2]}/{date_str[2:4]}/{date_str[4:6]}" if len(date_str) == lengths['date'] else date_str

    test_date = decode_format_date(offsets['test_date'])
    manuf_date = decode_format_date(offsets['manuf_date'])
    factory_date = decode_format_date(offsets['factory_date'])
    burnin_date = decode_format_date(offsets['burnin_date'])

    # Extract Bench Test.
    bench_test_bytes = eeprom_buffer[offsets['bench_test']:offsets['bench_test'] + lengths['bench_test']]
    bench_test = bench_test_bytes.decode('ascii', errors='ignore').strip('\x00')

    # Extract Mfg Test.
    mfg_test_bytes = eeprom_buffer[offsets['mfg_test']:offsets['mfg_test'] + lengths['mfg_test']]
    mfg_test = mfg_test_bytes.decode('ascii', errors='ignore').strip('\x00')

    # Extract RMA Info.
    rma_info_bytes = eeprom_buffer[offsets['rma_info']:offsets['rma_info'] + lengths['rma_info']]
    rma_info = rma_info_bytes.decode('ascii', errors='ignore').strip('\x00')

    # Extract FIPS bit.
    fips_value = eeprom_buffer[offsets['fips']]
    fips_bit_set = (fips_value == 0xA8)

    # Redact sensitive fields if requested.
    if redacted:
        redacted_str = "REDACTED"
        eeprom_buffer[offsets['mac']:offsets['mac'] + lengths['mac']] = b'X' * lengths['mac']
        mac_address = redacted_str
        eeprom_buffer[offsets['serial']:offsets['serial'] + lengths['serial']] = b'X' * lengths['serial']
        serial_number = redacted_str
        eeprom_buffer[offsets['manuf_date']:offsets['manuf_date'] + lengths['date']] = b'X' * lengths['date']
        manuf_date = redacted_str

    info = {
        'mac_address': mac_address,
        'module_id': module_id_str,
        'version_number': version_number,
        'buckhound': buckhound,
        'serial_number': serial_number,
        'part_number': part_number,
        'test_date': test_date,
        'manufacture_date': manuf_date,
        'factory_date': factory_date,
        'burnin_date': burnin_date,
        'bench_test': bench_test,
        'mfg_test': mfg_test,
        'rma_info': rma_info,
        'fips_bit_set': fips_bit_set,
        'pid_prom': eeprom_buffer[offsets['pid_prom']:offsets['pid_prom'] + lengths['pid_prom']],
        'module_data': eeprom_buffer[offsets['module_data']:offsets['module_data'] + lengths['module_data']],
    }

    # Build a multiline log message.
    lines = [
        ("MAC Address", info['mac_address']),
        ("Module ID", info['module_id']),
        ("Version Number", info['version_number']),
        ("Buckhound?", info['buckhound']),
        ("SN", info['serial_number']),
        ("Part Number", info['part_number']),
        ("Test Date", info['test_date']),
        ("Manufacture Date", info['manufacture_date']),
        ("Factory Date", info['factory_date']),
        ("Burn-in Date", info['burnin_date']),
        ("Bench Test", info['bench_test']),
        ("Mfg Test", info['mfg_test']),
        ("RMA Info", info['rma_info']),
        ("FIPS Enable", info['fips_bit_set']),
    ]
    max_label_length = max(len(label) for label, _ in lines)
    msg = "\n".join(f"{label.ljust(max_label_length)} : {value}" for label, value in lines)
    log.info(msg)

    return info, eeprom_buffer
